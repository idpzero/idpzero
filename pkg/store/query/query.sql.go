// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query.sql

package query

import (
	"context"
	"database/sql"
)

const createAuthRequest = `-- name: CreateAuthRequest :one
INSERT INTO auth_requests (
    id,
    application_id,
    redirect_uri,
    state,
    prompt,
    login_hint,
    max_auth_age_seconds,
    user_id,
    scopes,
    response_type,
    response_mode,
    code_challenge,
    code_challenge_method,
    nonce,
    complete,
    created_at,
    authenticated_at
  )
VALUES
  (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,?,?, ?) RETURNING id, application_id, redirect_uri, state, prompt, login_hint, max_auth_age_seconds, user_id, scopes, response_type, response_mode, nonce, code_challenge, code_challenge_method, complete, created_at, authenticated_at, auth_code
`

type CreateAuthRequestParams struct {
	ID                  string
	ApplicationID       string
	RedirectUri         string
	State               string
	Prompt              string
	LoginHint           string
	MaxAuthAgeSeconds   int64
	UserID              string
	Scopes              string
	ResponseType        string
	ResponseMode        string
	CodeChallenge       string
	CodeChallengeMethod string
	Nonce               string
	Complete            bool
	CreatedAt           int64
	AuthenticatedAt     int64
}

func (q *Queries) CreateAuthRequest(ctx context.Context, arg CreateAuthRequestParams) (*AuthRequest, error) {
	row := q.db.QueryRowContext(ctx, createAuthRequest,
		arg.ID,
		arg.ApplicationID,
		arg.RedirectUri,
		arg.State,
		arg.Prompt,
		arg.LoginHint,
		arg.MaxAuthAgeSeconds,
		arg.UserID,
		arg.Scopes,
		arg.ResponseType,
		arg.ResponseMode,
		arg.CodeChallenge,
		arg.CodeChallengeMethod,
		arg.Nonce,
		arg.Complete,
		arg.CreatedAt,
		arg.AuthenticatedAt,
	)
	var i AuthRequest
	err := row.Scan(
		&i.ID,
		&i.ApplicationID,
		&i.RedirectUri,
		&i.State,
		&i.Prompt,
		&i.LoginHint,
		&i.MaxAuthAgeSeconds,
		&i.UserID,
		&i.Scopes,
		&i.ResponseType,
		&i.ResponseMode,
		&i.Nonce,
		&i.CodeChallenge,
		&i.CodeChallengeMethod,
		&i.Complete,
		&i.CreatedAt,
		&i.AuthenticatedAt,
		&i.AuthCode,
	)
	return &i, err
}

const createKey = `-- name: CreateKey :one
INSERT INTO keys (
    id,
    alg,
    usage,
    public_key,
    private_key,
    created_at
  )
VALUES
  (?, ?, ?, ?, ?, ?) RETURNING id, alg, usage, public_key, private_key, created_at
`

type CreateKeyParams struct {
	ID         string
	Alg        string
	Usage      string
	PublicKey  string
	PrivateKey string
	CreatedAt  int64
}

func (q *Queries) CreateKey(ctx context.Context, arg CreateKeyParams) (*Key, error) {
	row := q.db.QueryRowContext(ctx, createKey,
		arg.ID,
		arg.Alg,
		arg.Usage,
		arg.PublicKey,
		arg.PrivateKey,
		arg.CreatedAt,
	)
	var i Key
	err := row.Scan(
		&i.ID,
		&i.Alg,
		&i.Usage,
		&i.PublicKey,
		&i.PrivateKey,
		&i.CreatedAt,
	)
	return &i, err
}

const createToken = `-- name: CreateToken :one
INSERT INTO tokens (
    id,
    auth_request_id,
    application_id,
    refresh_token_id,
    subject,
    audience,
    expiration,
    scopes,
    created_at
  )
VALUES
  (?, ?, ?, ?, ?, ?, ?,?, ?) RETURNING id, auth_request_id, application_id, refresh_token_id, subject, audience, expiration, scopes, created_at
`

type CreateTokenParams struct {
	ID             string
	AuthRequestID  sql.NullString
	ApplicationID  string
	RefreshTokenID string
	Subject        string
	Audience       string
	Expiration     int64
	Scopes         string
	CreatedAt      int64
}

func (q *Queries) CreateToken(ctx context.Context, arg CreateTokenParams) (*Token, error) {
	row := q.db.QueryRowContext(ctx, createToken,
		arg.ID,
		arg.AuthRequestID,
		arg.ApplicationID,
		arg.RefreshTokenID,
		arg.Subject,
		arg.Audience,
		arg.Expiration,
		arg.Scopes,
		arg.CreatedAt,
	)
	var i Token
	err := row.Scan(
		&i.ID,
		&i.AuthRequestID,
		&i.ApplicationID,
		&i.RefreshTokenID,
		&i.Subject,
		&i.Audience,
		&i.Expiration,
		&i.Scopes,
		&i.CreatedAt,
	)
	return &i, err
}

const getAuthRequestByAuthCode = `-- name: GetAuthRequestByAuthCode :one
SELECT id, application_id, redirect_uri, state, prompt, login_hint, max_auth_age_seconds, user_id, scopes, response_type, response_mode, nonce, code_challenge, code_challenge_method, complete, created_at, authenticated_at, auth_code FROM
  auth_requests
WHERE
  auth_code = ? LIMIT 1
`

func (q *Queries) GetAuthRequestByAuthCode(ctx context.Context, authCode sql.NullString) (*AuthRequest, error) {
	row := q.db.QueryRowContext(ctx, getAuthRequestByAuthCode, authCode)
	var i AuthRequest
	err := row.Scan(
		&i.ID,
		&i.ApplicationID,
		&i.RedirectUri,
		&i.State,
		&i.Prompt,
		&i.LoginHint,
		&i.MaxAuthAgeSeconds,
		&i.UserID,
		&i.Scopes,
		&i.ResponseType,
		&i.ResponseMode,
		&i.Nonce,
		&i.CodeChallenge,
		&i.CodeChallengeMethod,
		&i.Complete,
		&i.CreatedAt,
		&i.AuthenticatedAt,
		&i.AuthCode,
	)
	return &i, err
}

const getAuthRequestByID = `-- name: GetAuthRequestByID :one
SELECT id, application_id, redirect_uri, state, prompt, login_hint, max_auth_age_seconds, user_id, scopes, response_type, response_mode, nonce, code_challenge, code_challenge_method, complete, created_at, authenticated_at, auth_code FROM
  auth_requests
WHERE
  id = ? LIMIT 1
`

func (q *Queries) GetAuthRequestByID(ctx context.Context, id string) (*AuthRequest, error) {
	row := q.db.QueryRowContext(ctx, getAuthRequestByID, id)
	var i AuthRequest
	err := row.Scan(
		&i.ID,
		&i.ApplicationID,
		&i.RedirectUri,
		&i.State,
		&i.Prompt,
		&i.LoginHint,
		&i.MaxAuthAgeSeconds,
		&i.UserID,
		&i.Scopes,
		&i.ResponseType,
		&i.ResponseMode,
		&i.Nonce,
		&i.CodeChallenge,
		&i.CodeChallengeMethod,
		&i.Complete,
		&i.CreatedAt,
		&i.AuthenticatedAt,
		&i.AuthCode,
	)
	return &i, err
}

const getKeyByID = `-- name: GetKeyByID :one
SELECT id, alg, usage, public_key, private_key, created_at FROM
  keys
WHERE
  id = ? LIMIT 1
`

func (q *Queries) GetKeyByID(ctx context.Context, id string) (*Key, error) {
	row := q.db.QueryRowContext(ctx, getKeyByID, id)
	var i Key
	err := row.Scan(
		&i.ID,
		&i.Alg,
		&i.Usage,
		&i.PublicKey,
		&i.PrivateKey,
		&i.CreatedAt,
	)
	return &i, err
}

const getKeysByUse = `-- name: GetKeysByUse :many
SELECT id, alg, usage, public_key, private_key, created_at FROM
  keys
WHERE
  usage = ?
`

func (q *Queries) GetKeysByUse(ctx context.Context, usage string) ([]*Key, error) {
	rows, err := q.db.QueryContext(ctx, getKeysByUse, usage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Key
	for rows.Next() {
		var i Key
		if err := rows.Scan(
			&i.ID,
			&i.Alg,
			&i.Usage,
			&i.PublicKey,
			&i.PrivateKey,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTokenByID = `-- name: GetTokenByID :one
SELECT id, auth_request_id, application_id, refresh_token_id, subject, audience, expiration, scopes, created_at FROM
  tokens
WHERE
  id = ? LIMIT 1
`

func (q *Queries) GetTokenByID(ctx context.Context, id string) (*Token, error) {
	row := q.db.QueryRowContext(ctx, getTokenByID, id)
	var i Token
	err := row.Scan(
		&i.ID,
		&i.AuthRequestID,
		&i.ApplicationID,
		&i.RefreshTokenID,
		&i.Subject,
		&i.Audience,
		&i.Expiration,
		&i.Scopes,
		&i.CreatedAt,
	)
	return &i, err
}

const updateAuthCode = `-- name: UpdateAuthCode :execrows
UPDATE auth_requests 
SET auth_code = ?
WHERE id = ?
`

type UpdateAuthCodeParams struct {
	AuthCode sql.NullString
	ID       string
}

func (q *Queries) UpdateAuthCode(ctx context.Context, arg UpdateAuthCodeParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateAuthCode, arg.AuthCode, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateAuthRequestUser = `-- name: UpdateAuthRequestUser :execrows
UPDATE auth_requests 
SET user_id = ?, complete = 1, authenticated_at = ? 
WHERE id = ?
`

type UpdateAuthRequestUserParams struct {
	UserID          string
	AuthenticatedAt int64
	ID              string
}

func (q *Queries) UpdateAuthRequestUser(ctx context.Context, arg UpdateAuthRequestUserParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateAuthRequestUser, arg.UserID, arg.AuthenticatedAt, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
